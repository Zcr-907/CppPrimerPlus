#include <unistd.h>
#include <stdio.h>
/**
 * 异常控制流:
 *  异步 中断 来自IO设备,并不是程序导致的异常(网络设备请求到达)
 *  同步 陷阱 0X80,系统调用陷入内核
 *  同步 故障 程序执行指令导致的异常(存在修复可能),比如缺页异常(第一次获取数据时数据未存在页表中,加载之后继续执行当前指令)
 *  同步 终止 程序遇到不可修复的错误,或者硬件错误
 * @return
 */
int main() {
    pid_t pid;
    int x = 1;

    /**
     * fork函数"一次调用两次返回"
     * 返回给父进程: 子进程的PID
     * 返回给子进程: 0
     */
    pid = fork();
    if (pid == 0) {
        printf("child : x=%d\n", ++x);
        _exit(0);
    }

    /**
     * 对于父子进程内的printf(): 父子进程拥有在fork前x=1的值
     *                        在这之后父子进程各自对x的修改不会影响到对方的数据副本
     *                        这是由于在fork是子进程拷贝了一份父进程的数据副本,并在该副本上进行读取
     * 所以输出如下
     *  parent : x=0
     *  child : x=2
     */
    printf("parent : x=%d\n", --x);
    _exit(0);
}

