// VM: virtual memory
//     虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间


/**
 * 物理地址: 主存数据地址
 * 虚拟寻址: CPU生成一个虚拟地址来访问主存,主存中的"内存管理单元(MMU)"通过页表动态将虚拟地址翻译成内存中的物理地址
 * 虚拟内存: 虚 拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组
 *
 * 置换页过程:
 *  CPU读取VP3,查询VP3对应也表中的条目号
 *      > 有效位=1,通过对应的物理地址获取数据
 *      > 有效位=0,缺页异常,(加载VP3进对应的物理页),(缺页,计算出牺牲页,如果dirty就写回磁盘,然后将虚拟页写入物理页)
 *
 * 1.通过页表将磁盘上的虚拟页与内存上的物理页联系起来
 * 2.通过在页表中的条目前添加操作许可标识位,来管理程序对数据页的行为
 * 3.当非法访问数据物理页时将会触发段错误
 */

/**
 * CPU一次寻址过程的理解
 * 1.CPU根据虚拟地址(VA)尝试在内存管理单元(MMU)中去匹配块表(TLB)
 * > 将虚拟页号(VPN)分割成TLB的标记索引(TLBT)和组索引(TLBI)
 * > 根据TLB中查找到的信息[物理页号(PPN),有效标记位]判断是否有效
 * > 如果有效的话将PPN与VA切割出的虚拟地址偏移(VPO)拼接成物理地址
 * > 将得到的物理地址分割成组索引(CI),块索引(CO),组标记(CT),通过有效标记位和上诉信息在RAM中的缓存块中匹配正确的数据返回给CPU
 */

/**
 * 简述一个运行在Linux上的Intel core i7的寻址过程
 * 四个独立的核,拥有一个层次结构的高速缓存结构(L1,L2),一个层次结构的块表(TLB),与前者一一对应
 *
 * 1.CPU发送虚拟地址给L1-TLB,根据计算规则尝试从TLB中获取到对应的物理页号(PPN),
 *   基于虚拟地址偏移(VPO)与物理地址偏移(PPO)都是相同的(低12位),所以可以拼接出一个完整的物理地址
 * 2.根据得到的物理地址在L1高速缓存中,找到对应的数据块
 * 3.如果step1不成功,就直接将VPN分成4片(VPN1,VPN2,VPN3,VPN4)分别对应四级页表结构找到最终的PPN,回到step2
 *   这是基于VPN与PTE(页表条目)一一对应的关系
 * 4.如果step2不成功,将上述步骤得到的物理地址请求下级缓存,
 *   下级缓存如果缓存命中就返回数据,缓存不命中直至发生缺页中断异常,将数据换入物理内存,负责重复step4
 */
