// Created by Zcr on 2022/9/14.
#include <iostream>

union number {
    float a;
    int b;
};

void test_00() {
    using namespace std;
    // 测试证明: 通过2个同类型的指针相减,可以得到2个指针间距离了X个类型单位的距离
    int arr[] = {1, 2, 3, 4, 5};
    int step = &arr[2] - &arr[1];
    cout << "arr[2] 与 arr[1] 距离了几个单位: " << step << endl;
    int *ip = &arr[2];

    // 测试证明: 通过指针加减常数,可以进行类似与数组的操作 *(2 + ip) > arr[2]
    cout << "arr[2] 之后的第二个元素: " << *(2 + ip) << endl;

    int arr2[][3] = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
    };
    // 输出: 12 > 3个元素 * 4Byte
    cout << "sizeof(arr2[0]): " << sizeof(arr2[0]) << endl;

    // 输出: 4 > 其实等同于取值arr2[1][0] > 因为为int类型所以输出4
    // 测试证明: *arr2[1],其实在尝试获取arr2[1][0]的值,arr2[1],表示为第二个内层数组的首地址,取该地址所存储的值也就是4
    cout << "sizeof(*arr2[0]): " << sizeof(*arr2[1]) << endl;
    cout << "*arr2[1]: " << *arr2[1] << endl;

    // 测试证明: 二者结果相同,都表示arr2[0][0]
    printf("%d\n", **arr2);
    printf("%d\n", *arr2[0]);

    // 多维数组的指针表示法
    int (*pt)[3];
    pt = (int[2][3]) {{1, 2, 3},
                      {4, 5, 6}};

    /**
     * C语言是没有缓冲区溢出检测的,这就代表了。缓冲区溢出会导致许多不可预测的错误
     * 1.程序报错
     * 2.ret(返回地址时)由于缓冲区溢出导致被修改,执行到了错误代码
     * 3.防止通过恶意使用缓冲区溢出导致程序错误执行的方法
     *      : 栈随机化,在栈开始前随机扩展一定长度的栈空间,由此分配栈内存
     *      : 栈破坏检测(栈保护者机制),在缓冲区边界设置金丝雀值,检测是否被修改
     *      : 将内存页中的读,执行权限分离,指定页才有执行权限,防止被插入恶意代码
     */

    /**
     * 浮点代码
     *  : 使用XMM寄存器来存储和返回数据
     *  : xmm0~xmm7为保存参数的寄存器
     *  : xmm0用来返回浮点值
     *  : 所有的XMM寄存器都为调用者保存
     */

    /**
     * 联合的使用
     *  : 与结构不同的是,并不能同时存储多个字段
     *  : 设置任何一个字段都将独占联合对象的内存地址(替换之前的旧值)
     *  : 但是可以如以下对相同的值进行不同的数据表示(这里将float使用int来表示,并不想强制转化一样,这里并不会修改bit)
     */
    union number num{};
    num.a = 1.0f;
    cout << num.b << endl;


}


